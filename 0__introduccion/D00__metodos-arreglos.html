<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M칠todos para trabajar con arreglos</title>
    <link rel="shortcut icon" href="#">
    <link rel="stylesheet" href="../../assets/style.css">
</head>
<body>
    <section>
        <h1 id="titulo">M칠todos para trabajar con arreglos</h1>
        <h2 class="text-center"></h2>
    </section>
    <script>

        // 游늷 .m칠todo() - Definici칩n
        console.log('______ M칄TODO X: plantillaX.m칠todo() ______')
        // Declaraci칩n de variables
        /*
            1 - Argumentos
        */
        // Aplicar m칠todo

        // 游늷 .length - Nos permite conocer la cantidad de elementos que tiene un arreglo
        console.log('______ M칄TODO 1: colores1.length ______')
        const colores1 = ['Rojo', 'Verde', 'Azul', 'Morado']
        console.log(colores1)
        /**/
        console.log(colores1.length)
        // Output: 4
        console.log('')


        // 游늷 .toString() - Nos permite transformar un arreglo a una cadena de texto
        console.log('______ M칄TODO 2: colores2.toString() ______')
        const colores2 = ['Rojo', 'Verde', 'Azul', 'Morado']
        console.log(colores2)
        /**/
        console.log(colores2.toString())
        // Output: Rojo,Verde,Azul,Morado
        console.log('')


        // 游늷 .join() nos permite transformar un arreglo a una cadena de texto y separar cada elemento por la letra que nosotos queramos
        console.log('______ M칄TODO 3: colores3.join(-) ______')
        const colores3 = ['Rojo', 'Verde', 'Azul', 'Morado']
        console.log(colores3)
        /**/
        console.log(colores3.join('-'))
        // Output: Rojo-Verde-Azul-Morado
        console.log('')


        // 游늷 .sort() nos permite ordenar los elementos (n칰meros y texto) de un arreglo de forma alfab칠tica
        console.log('______ M칄TODO 4: numeros4.sort() ______')
        const numeros4 = [6, 9, 4, 9, 2, 2, 3, 8, 7]
        console.log(numeros4)
        /**/
        console.log(numeros4.sort()) // Modifica el arreglo original
        // Output: [2, 2, 3, 4, 6, 7, 8, 9, 9]
        console.log('')


        // 游늷 .reverse() nos permite ordenar los elementos (n칰meros y texto) de un arreglo de forma descendente
        console.log('______ M칄TODO 5: numeros5.reverse() ______')
        const numeros5 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        console.log(numeros5)
        /**/
        console.log(numeros5.reverse()) // Modifica el arreglo original
        // Output: [2, 2, 3, 4, 6, 7, 8, 9, 9]
        console.log('')


        // 游늷 .concat() permite juntar 2 arreglos en uno solo
        console.log('______ M칄TODO 6: numeros6.concat(letras_6) ______')
        const numeros6 = [1, 2, 3, 4, 5, 6, 7, 8, 9]
        const letras_6 = ['a', 'z', 'x', 'b', 'c', 'm', 'p'];
        console.log(numeros6)
        console.log(letras_6)
        /**/
        console.log(numeros6.concat(letras_6))
        // Output: [1, 2, 3, 4, 5, 6, 7, 8, 9, 'a', 'z', 'x', 'b', 'c', 'm', 'p']
        console.log('')


        // 游늷 .push() permite agregar un elemento al final del arreglo
        console.log("______ M칄TODO 7: colores7.push('turquesa') ______")
        const colores7 = ['Rojo', 'Verde', 'Azul', 'Morado']
        console.log(colores7)
        /**/
        console.log(colores7.push('turquesa'))  // Retorna la longitud del array
        // Output: 5
        console.log('')


        // 游늷 .pop() permite eliminar un elemento al final del arreglo
        console.log("______ M칄TODO 8: colores8.pop() ______")
        const colores8 = ['Rojo', 'Verde', 'Azul', 'Morado']
        console.log(colores8)
        /**/
        console.log(colores8.pop()); // Retorna el elemento eliminado
        // Output: Morado
        console.log('')


        // 游늷 .shift() permite eliminar un elemento al principio del arreglo
        console.log("______ M칄TODO 9: colores9.shift() ______")
        const colores9 = ['Rojo', 'Verde', 'Azul', 'Morado']
        console.log(colores9)
        /**/
        console.log(colores9.shift()); // Retorna el elemento eliminado
        // Output: Rojo
        console.log('')


        // 游늷 .unshift() permite agregar un elemento al principio del arreglo
        console.log("______ M칄TODO 10: colores10.unshift('Gris') ______")
        const colores10 = ['Rojo', 'Verde', 'Azul', 'Morado']
        console.log(colores10)
        /**/
        console.log(colores10.unshift('Gris')); // Retorna la nueva longitud del arreglo
        // Output: 5
        console.log('')


        // 游늷 .splice() permite eliminar/insertar/sustituir elementos en cualquier parte del arreglo
        console.log("______ M칄TODO 11: amigos11.splice(1, 2, 'Rafael', 'Roberto') ______")
        const amigos11 = ['Alejandro', 'Cesar', 'Manuel'];
        console.log(amigos11)
        /* 
            1er parametro - Posici칩n donde queremos comenzar a insertar los elementos. Si ponemos 0 los elementos aparecen al inicio
            2do parametro - Si queremos eliminar elementos del arreglo desde la posici칩n indicada. Si ponemos 0 no se eliminar치n elementos
            Resto parametros - Los elementos a insertar. 
        */
        amigos11.splice(1, 2, 'Rafael', 'Roberto');
        console.log(amigos11)
        // Output: ['Alejandro', 'Rafael', 'Roberto']
        console.log('')


        // 游늷 .slice() permite copiar una parte de un arreglo a otro
        console.log("______ M칄TODO 12: frutas12.slice(2,4) ______")
        const frutas12 = ['Fresa', 'Manzana', 'Uva', 'Pi침a', 'Naranja', 'Melon'];
        console.log(frutas12);
        /*
            1er parametro - Posici칩n desde donde queremos copiar
            2do parametro - Hasta antes de que elemento copiar
        */
        const frutasFavoritas12 = frutas12.slice(2, 5)
        console.log(frutasFavoritas12)
        // Output: ['Uva', 'Pi침a', 'Naranja']
        console.log('')


        // 游늷 .indexOf() permite obtener el index de un elemento. 
        // Si no hay elemento nos retorma -1
        console.log("______ M칄TODO 13: conocidos13.indexOf('Gema') ______")
        const conocidos13 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Gema', 'Diana', 'Sara', 'Gema'];
        console.log(conocidos13)
        /**/
        console.log(conocidos13.indexOf('Gema')); // Devuelve el primer index del elemento que encontr칩
        // Output: 5
        console.log('')


        // 游늷 .lastIndexOf() permite obtener el 칰ltimo index de un elemento. 
        // Si no hay elemento nos retorma -1
        console.log("______ M칄TODO 14: conocidos14.lastIndexOf('Gema') ______")
        const conocidos14 = ['Carlos', 'Gema', 'Estefania', 'Rodrigo', 'Rafael', 'Gema', 'Diana', 'Sara', 'Gema'];
        console.log(conocidos14)
        /**/
        console.log(conocidos14.lastIndexOf('Gema')); // Devuelve el 칰ltimo index del elemento que encontr칩
        // Output: 8
        console.log('')


        // 游늷 .forEach() permite ejecutar una funci칩in por cada elemento
        console.log("______ M칄TODO 15: conocidos15.forEach(() => {}) ______")
        const conocidos15 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Gema', 'Diana', 'Sara', 'Gema'];
        console.log(conocidos15)
        /*
            Primer par치metro (requerido) siempre es la forma que identificamos los elementos del array
            Segundo par치metro (opcional) es la posici칩n
            Tercer par치metro (opcional) array completo. El array sobre el cual forEach() est치 siendo llamado.
        */
        conocidos15.forEach((nombre15, index15) => {
            console.log(`Hola ${nombre15}`, index15)
        })
        // Output:
        // Hola Carlos 0
        // Hola Rafael 1
        // Hola Estefania 2
        // Hola Rodrigo 3
        // Hola Rafael 4
        // Hola Gema 5
        // Hola Diana 6
        // Hola Sara 7
        // Hola Gema 8
        console.log('')


        // 游늷 .find() Permite recorrer un arreglo y devuelve el primer elemento que retornemos con la sentencia return
        // permite ejecutar una funci칩in por cada elemento al igual que .forEach()
        console.log("______ M칄TODO 16: grupo16.find(() => {}) ______")
        const grupo16 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Gema', 'Diana', 'Sara', 'Gema'];
        console.log(grupo16)
        /* Dentro del primer () escribimos como queremos identificar a cada uno de los elementos */
        const personaSeleccionada16 = grupo16.find((nombre16) => {
            if (nombre16[0] === 'C') {
                return nombre16;
            }
        })
        console.log(personaSeleccionada16)
        // Output: Carlos
        console.log('')


        // 游늷 .map() Permite ejecutar una funci칩n por cada elemento y crear un nuevo arreglo en base a los resultados de esa funci칩n. 
        // El nuevo arreglo va a tener el mismo n칰mero de elementos que el original
        console.log("______ M칄TODO 17: grupo17.map(() => {}) ______")
        const grupo17 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Gema', 'Diana', 'Sara', 'Gema'];
        console.log(grupo17)
        /* Dentro del primer () escribimos como queremos identificar a cada uno de los elementos */
        const grupoMayusculas = grupo17.map((nombre17) => nombre17.toUpperCase()) // Funci칩n flecha reducida
        console.log(grupoMayusculas)
        // Output: ['CARLOS', 'RAFAEL', 'ESTEFANIA', 'RODRIGO', 'RAFAEL', 'GEMA', 'DIANA', 'SARA', 'GEMA']
        console.log('')


        // 游늷 .filter() igual que .map(), pero el nuevo arreglo solo devuelve los resultados que cumplen con una condici칩n
        console.log("______ M칄TODO 18: grupo18.filter(() => {}) ______")
        const grupo18 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Diana', 'Sara', 'Gema'];
        console.log(grupo18)
        /* Dentro del primer () escribimos como queremos identificar a cada uno de los elementos */
        const grupo4Letras18 = grupo18.filter((nombre18) => {
            if (nombre18.length === 4) {
                return nombre18;
            }
        })
        console.log(grupo4Letras18)
        // Output: ['Sara', 'Gema']
        console.log('')


        // 游늷 .includes() Nos permite saber si un arreglo contiene el elemento especificado
        console.log("______ M칄TODO 19: grupo19.includes('Julio') ______")
        const grupo19 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Diana', 'Sara', 'Gema'];
        console.log(grupo19)
        /*
            Dentro del primer () escribimos como queremos identificar a cada uno de los elementos 
            La sentencia devuelve true o false
        */
        console.log(`El arreglo contiene 'Julio'? ${grupo19.includes('Julio')}`)
        // Output: El arreglo contiene 'Julio'? false
        console.log('')


        // 游늷 .every() Nos permite ejecutar un condicional sobre cada elemento y nos devuelve true si TODOS los elementos cumplieron la condici칩n.
        // Muy 칰ttil para validar si los campos de un formlario son correctos
        console.log("______ M칄TODO 20: grupo20.every(() => {}) ______")
        const grupo20 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Diana', 'Sara', 45];
        console.log(grupo20)
        /*
            Dentro del primer () escribimos como queremos identificar a cada uno de los elementos 
            La sentencia devuelve true o false
        */
        const IsStringGrupo20 = grupo20.every((nombre20) => {
            if (typeof nombre20 === "string") {
                return true;
            } else {
                return false;
            }
        })
        console.log(`Todos los nombres son string?: ${IsStringGrupo20}`)
        // Output: Todos los nombres son string?: false
        console.log('')


        // 游늷 .some() Nos permite ejecutar un condicional sobre cada elemento y nos devuelve true si ALGUNOS de los elementos cumplieron la condici칩n.
        console.log("______ M칄TODO 21: grupo21.some(() => {}) ______")
        const grupo21 = ['Carlos', 'Rafael', 'Estefania', 'Rodrigo', 'Rafael', 'Diana', 'Sara', 45];
        console.log(grupo21)
        /*
            Dentro del primer () escribimos como queremos identificar a cada uno de los elementos 
            Devuelve True si hay un valor invalido
            Devuelve False si no hay algun valor invalido
        */
        const IsStringGrupo21 = grupo21.some((nombre20) => {
            if (typeof nombre20 !== "string") {  // Preguntamos si alg칰n elemento es distinto a una cadena de texto
                return true;
            } else {
                return false;
            }
        })
        console.log(`El arreglo es inv치lido? ${IsStringGrupo21}`)
        // Output: El arreglo es inv치lido? true
        console.log('')

        // 游늷 .substring(II) se utiliza para extraer una parte de una cadena (string) y devolver esa parte como una nueva cadena. Funciona tomando dos argumentos
        console.log("______ M칄TODO 22: carta22.substring(II) ______")
        const carta22 = '10A'
        console.log(carta22)
        /*
            1 - 칈ndice inicial (obligatorio): El 칤ndice del car치cter donde comenzar치 la extracci칩n.
            2 - 칈ndice final (opcional): El 칤ndice del car치cter donde se detendr치 la extracci칩n. 
        */
       const valor22 = carta22.substring(0, carta22.length - 1)
       console.log(valor22)
       // Output: 10
       console.log('')

    </script>
</body>
</html>